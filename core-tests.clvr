: fibr
	-- Recursive version. Executes in 17.98 sec on an i7!
	-- 
	0 -> 1+ ;;
	1 -> ;;
	_ ->
		push
		peek 2 - fibr
		pop  1 - fibr +
	;;
;

: next-fib  ( n0 n1 -- n1 n2 )
	stash + pop swap
;

: fibi  ( n -- int )
	-- iterative version. Executes in 0.0 sec on an i7
	push
	1 1 pop times
		next-fib
	repeat
	drop
;

section: Args
	[ argc @ ] 1 test
;


# 10 constant: ten
# -1 constant: minus-one

section: Constants
	[ ten ] 10 test
	[ minus-one ] -1 test
	-- constants defined in foundation
	[ 0 ] 0 test
	[ 1 ] 1 test
;

section: Units
	[ 1 kiB ] 1024 test
	[ 1 MiB ] 1024 1024 * test
	[ 1 GiB ] 1024 1024 1024 * * test
	[ 1 cell ] CellSize  test
;

variable: test-var

section: Variables
	[ test-var @ ] 0 test
	[ test-var inc-var test-var @ ] 1 test
	[ test-var inc-var test-var @ ] 2 test
	[ test-var dec-var test-var @ ] 1 test
	[ test-var dec-var test-var @ ] 0 test
	[ test-var dec-var test-var @ ] -1 test
	[ test-var label-for-var @    ] 8 test
	[ interpreter label-for-var @ ] 11 test
;
section: Lambdas
	[          [ 1 2 + ] call ]  3  test
	[          2 [ 3 + ] call ]  5  test
	[ [ 3 [ 5 + ] call ] call ]  8  test
	[ [ 5 [ 8 + ] ] call call ] 13  test
;
section: Immediate code-blocks
	[ #[ 1 1 + compile-literal ] 1 + ] 3 test
;
section: Arithmetic
	[  1 1 + ]         2 test
	[ -1 1 + ]         0 test
	[  0 1 - ]        -1 test
	[ 1 10 100 + + ] 111 test

	[ 0 1000 *  ]   0 test
	[ 2    3 *  ]   6 test
	[      2 2* ]   4 test
	[     -2 2* ]  -4 test
	[    -11 2* ] -22 test

	[ 100 dup + ] 200 test

	[ 1 100 max ] 100 test
	[ 1 100 min ]   1 test

	[ -1 1 min ] -1 test
	[ -1 1 max ]  1 test

	[  0 neg ]  0 test
	[  1 neg ] -1 test
	[ -1 neg ]  1 test
;
section: Date and time
	[ 1:00:00 ] 3600 test
	[ 0:10:56 ] 656  test
	[ 2000-01-01 ] 20000101 test
;
section: Bitwise operations
	[ 0 not ] -1 test
	[ 1 not ] -2 test
	[ 1 2 4 or or ] 7 test
	[ 1 1 or ] 1 test
	[ 2 3 and ] 2 test
	[ 2 3 xor ] 1 test
	[ -1 -1 xor ] 0 test
;
section: Bit-shifting
	[ 1 2 bits-up ] 4 test
	[ hex: 7fffffff 1 bits-up ] hex: fffffffe test
	[ -2 31 bits-up ] 0 test
	[ -256 31 bits-up ] 0 test
	[ -256 1 bits-down ] -128 test
;
section: Comparisons
	[  1 2 less-than? ] true test
	[  1 0 less-than? ] false test
	[  1 1 less-than? ] false test
	[ -1 1 less-than? ] true test

	[  1 2 more-than? ] false test
	[  1 0 more-than? ] true test
	[  1 1 more-than? ] false test
	[ -1 1 more-than? ] false test

	[  1 2 or-more? ] false test
	[  1 0 or-more? ] true test
	[  1 1 or-more? ] true test
	[ -1 1 or-more? ] false test
	
	[  1 2 or-less? ] true test
	[  1 0 or-less? ] false test
	[  1 1 or-less? ] true test
	[ -1 1 or-less? ] true test
	
	[  1 2 eq? ] false test
	[  1 0 eq? ] false test
	[  1 1 eq? ] true test
	[ -1 1 eq? ] false test

	[  1 2 not-eq? ] true test
	[  1 0 not-eq? ] true test
	[  1 1 not-eq? ] false test
	[ -1 1 not-eq? ] true test

	[  1 2 matches? nip ] false test
	[  1 0 matches? nip ] false test
	[  1 1 matches? nip ] true test
	[ -1 1 matches? nip ] false test

	[ 2  1 3  between? ] true test
	[ 3  1 2  between? ] false test
	[ 0  -1 1 between? ] true test
	[ 0  0 1  between? ] true test
;
section: Booleans
	[ 0 ]             false  test
	[ -1 ]            true   test
	[ true  not ]     false  test
	[ false not ]     true   test
	[ true not not ]  true   test
	[ false not not ] false  test
	[ 1    bool ]     true   test
	[ 703  bool ]     true   test
	[ 0    bool ]     false  test
;
section: Prefixes
	[ bin: 100 ] 4 test
	[ oct: 100 ] 64 test
	[ hex: ff ] 255 test
	[ c: x ] hex: 78 test
	-- multi-byte chars -- Warning: tests are non-portable across byte order
	-- and source-file encoding.
	[ c: £ ] hex: a3c2 test
	[ c: ø ] hex: b8c3 test
	[ c: € ] hex: ac82e2 test
	-- slightly hacky way of packing up to four chars
	-- into a cell
	[ c: w ] hex: 77 test
	[ c: wx ] hex: 7877 test
	[ c: wxy ] hex: 797877 test
	[ c: wxyz ] hex: 7a797877 test
;
section: Return stack
	[ 12121 push pop ]   12121 test
	[ 10 push  20 push
	  pop 2* pop +   ]      50 test
	[ 10 push peek pop + ]  20 test
;	
section: Data stack
	[ 111 222 nip ] 222 test
	[ 111 222 drop ] 111 test
;
section: Fibonacci
	[ 40 fibi ] 165580141 test
	-- [ 40 fibr ] 165580141 test
;
section: Align
	[ here     align ] here               test
	[ here 1 + align ] next-cell          test
	[ here 3 + align ] next-cell          test
	[ here 4 + align ] next-cell          test
	[ here 5 + align ] here 2 cells after test
;
section: Allot
	[ 1      allot here ] next-cell           test
	[ 1 cell allot here ] next-cell           test
	[ 4      allot here ] next-cell           test
	[ 5      allot here ] here 2 cells after  test -- allocate 5 bytes (plus alignment = 2 cells)
;	


struct: emptyStruct end
struct: singleCellStruct              cell: .firstField    end
struct: field12Struct   #[ 3 cells ] field: .kasjldkajlk   end
struct: 2cellField5Struct
	     cell: .yksi
	     cell: .kaksi
	# 5 field: .kolme
end

section: Structures
	[ sizeof: emptyStruct ] 0 test
	[ sizeof: singleCellStruct ] 4 test
	[ sizeof: field12Struct ] 12 test
	[ sizeof: 2cellField5Struct ] 16 test
	
	[ 0 .yksi ] 0 test
	[ 0 .kaksi ] 4 test
	[ 0 .kolme ] 8 test
;
section: Comments
	[ 0 ( 1 + 
		      1+ ) ]     0 test
	[ 0 -- 1 +
		        1+ ]     1 test
	-- comments are nestable...
	[ 0 ( 1 + ( 1+ ) ) ] 0 test

	-- and can contain left and right parens that are not 
	-- distinct words
	[ 0 ( this is a comment (and this is part of 
	      the same comment) :) :(   ) ] 0 test
;
section: FileIO
	[ s" /etc/fstab" ReadOnly open ] 3 test
	[ s" /tmp/cantilever_out" WriteOnly open ] 4 test
	[ 4 file-length ] 0 test

	out-channel @
		4 out-channel !
		s" test" puts
		out-channel !

	[ 4 file-length ] 4 test
	[ 0   3 close ] 0 test
	[ 0   4 close ] 0 test
;
section: Strings
	[ s" hello" lens ] 5 test
	[ s" blah"  lens ] 4 test
	[ s" \"\""  lens ] 2 test
	[ "" lens ] 0 test
	[ z" hello world"     [ '.'   eq? ] scanz            ] false test
	[ z" hello world" dup [ 'spc' eq? ] scanz   5 -  eq? ] true  test
;
section: Null-terminated strings
	[ s" hello" 1 cell after lenz ] 5 test
	[ "" 1 cell after lenz ] 0 test
	[ z" hello" lenz ] 5 test
	[ z" \"\""  lenz ] 2 test
;
section: Dictionary
	[ s" wiffle" words find ] 0 test
	[ s" wiffle" findWord   ] 0 test
	[ s" blah"   words find ] 0 test
	[ s" blah"   findWord   ] 0 test
	[ s" @"      words find .cfa ] ' @ test
	[ s" !"      findWord   .cfa ] ' ! test
	[ ' @ cfa->entry .cfa ] ' @ test
	[ s" @" findWord .pfa ] ' @ cfa->pfa test
;


variable: emptyList
variable: singlet
variable: doublet
variable: new-elem

#[
	emptyList singlet !
	singlet doublet !
]

section: List handling
	[   emptyList length                        ] 0 test
	[ 0 emptyList [ drop 1+       ] each        ] 0 test
	[ 0 emptyList [ drop 1+ false ] search drop ] 0 test

	[   singlet   length                        ] 1 test
	[ 0 singlet   [ drop 1+       ] each        ] 1 test
	[ 0 singlet   [ drop 1+ false ] search drop ] 1 test

	[   doublet   length                        ] 2 test
	[ 0 doublet   [ drop 1+       ] each        ] 2 test
	[ 0 doublet   [ drop 1+ false ] search drop ] 2 test

	[ 0 words     [ drop 1+       ] each   ] words length test

	[ 0 words     [ drop 1+ false      ] search drop ] words length test
	[   words     [ drop false         ] search      ] 0 test
	[   words     [ drop true          ] search      ] words @ test
	[   words     [ .label s" @" strEq ] search      ]  ' @ cfa->entry test

	[   new-elem doublet cons  doublet @     ] new-elem  test
	[                          doublet @ @   ] singlet   test
	[                          doublet @ @ @ ] emptyList test
	[                        doublet @ @ @ @ ] 0 test
	[   doublet length ] 3 test
	
	[   doublet uncons ] new-elem test
	[   doublet @      ] singlet  test
	[   doublet length ] 2 test

	-- [   doublet reverse   doublet @   ] emptyList test
	-- [                     doublet @ @ ] singlet test
	-- [   doublet length ] 2 test 
;


declare: predeclared
: predeclBody   1 2 3 + +   ;

section: Pre-declaration
	[ ' predeclared cfa->pfa @ ] ' not-imlemented test
		
	-- test implementation using inline code block
	[ hex: deadbeef ] implements predeclared
	[ predeclared ] hex: deadbeef test	
	
	-- test using dictionary XT
	' predeclBody implements predeclared
	[ predeclared ] predeclBody test
	-- test
;

variable: tail-rs-depth
: non-tail-rs-depth-test
	rs-depth   tail-rs-depth @   max      tail-rs-depth !
	1- dup if
		non-tail-rs-depth-test
	else
		drop
	endif
;
: tail-rs-depth-test
	rs-depth   tail-rs-depth @   max      tail-rs-depth !
	1- dup if
		tail: tail-rs-depth-test
	else
		drop
	endif
;
: tail-test 1- dup if tail: tail-test endif ;

section: Tail-calls
	[ 10000000 tail-test ] 0 test
	[ rs-depth 1000 tail-test drop rs-depth eq? ] true test
	[ 1000 tail-rs-depth-test  tail-rs-depth @  rs-depth - ] 1 test
	0 tail-rs-depth ! -- reset counter
	[ 1000 non-tail-rs-depth-test   tail-rs-depth @ rs-depth - ] 1000 test
;

# run-tests
# test-report
# profile-report

-- vim:ft=cantilever
