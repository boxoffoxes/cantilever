9  constant: '\t'
10 constant: '\n'
27 constant: '\e'

: end-of-comment? '\n' = ;
: --   #immediate   ' end-of-comment? scan   drop  ;

-- and now we have comments. Yay!

-- allow aliasing of existing words without adding a
-- layer of indirection
: alias:  #immediate  -- ( xt -- )  ( -- )
	create-immed  ,    -- store the word being aliased
	does        @ ,  -- when called compile the aliased word
;

-- Lets us hide the current definition and call an earlier definition with 
-- the same name...
: #hidden   #immediate   dictionary @ .label   dup @ not  swap ! ; 
: #visible  #immediate  ` #hidden ; 

-- make address manipulation more readable...
' cell alias: cells
' -    alias: before
' +    alias: after

: next-cell  here   1 cell after   ;
: prev-cell  here   1 cell before  ;

-- a couple more readability constants...
-1 constant: true
0  constant: false

-- missing arithmetic
: /  /mod drop  ;

-- Text highlighting
: warning     WarningColour colour ;
: uncoloured  NoColour colour ;

-- now let's implement conditionals
: compile-jump     ,    here    0 ,  ;        --  xt -- addr
: compile-conditional-jump   ' zbranch  compile-jump ;
: compile-unconditional-jump ' branch   compile-jump ;
: jump-target   dup   here swap -   swap !  ;

variable: if-depth
: if     #immediate   compile-conditional-jump   if-depth inc-var  ;
: else   #immediate   compile-unconditional-jump   push   jump-target   pop ;
: endif  #immediate   jump-target   if-depth dec-var ;

-- exceptions are basically just variables
: exception:   #immediate    create-variable  ;

-- next up nestable block comments
: while-word  --   xt --
	-- consume words until the passed function returns false
	push
	word peek call if 
		pop
		tail: while-word
	else
		trash
	endif
;
: _nestable-comment   --  n word -- n bool
	1 cell after @     -- skip the word's length count
	stash ')' =    if  -- does the word equal ")"?
		1 -            -- yes, then reduce the depth count
		trash          -- and discard the saved word
	else
		pop '(' =  if 1 + endif  -- else if the word is (, increase the depth
	endif
	dup bool           -- convert the depth to a canonical boolean
;
: (    #immediate    1  ' _nestable-comment while-word    drop ;
( and now we have better comments! ( because they can be
  nested, and can span multiple lines ) )


-- let's implement simple pattern matching
-- variable: pattern-match-depth
-- variable: rs-usage

( : unbalanced-rs-error
	UnbalancedRSInBranch   warns
	warning    dictionary @ .label  warns    uncoloured
; )
: ->    #immediate
	' matches? ,
	compile-conditional-jump
	-- rs-usage @
	-- pattern-match-depth inc-var
;
: ;;    #immediate
	' return ,
	-- rs-usage @  if   unbalanced-rs-error   endif
	-- rs-usage !
	jump-target
	-- pattern-match-depth dec-var
;
' dup alias: _

( : forever    #immediate
	here ' lit , , ' push ,
	scratchpad-addr  -- somewhere for repeat to write to
;
: times      #immediate #hidden   ( -- addr )
	' lit , here 0 , ' push ,  -- push the address to return to at end of loop
	' times ,                  -- compile call to previous definition of times
; #visible
: repeat     #immediate
	' return ,
	here swap !
; )

-- Imperative looping
: times      #immediate   ( n -- )
	' push ,					-- push i
	here   ' peek ,				-- this is where we jump back to
	compile-conditional-jump    -- jump out of loop if i==0
	' pop , ' 1- , ' push ,     -- decrement the counter
	swap                        -- leave NoS:exit-jump ToS:start-of-loop
;
: forever    #immediate
	-1 compile-literal
	' push ,   here   ' peek ,
	compile-conditional-jump
	swap
;
: repeat     #immediate    ( exit-jump start-of-loop  --  )
	next-cell -    compile-unconditional-jump   !
	jump-target
	' trash ,
;

-- Now let's get strings...
exception: InvalidEscapeSequence
variable: string-terminator
: handle-str-esc  ( c -- c )
	'e' -> drop '\e' ;;
	'n' -> drop '\n' ;;
	't' -> drop '\t' ;;
	'0' -> drop   0  ;;
	'"' ->           ;;
	'\' ->           ;;
	_   -> drop drop drop   InvalidEscapeSequence raise ;;
;
: end-of-string?  ( c -- bool )
	string-terminator @
	    -> drop   0 ,b   align-dp     true  ;;
	'\' -> drop key handle-str-esc ,b false ;;
	_   -> ,b                         false ;;
;
: compile-string ( char -- str )
	string-terminator !
	here stash   0 ,  ' end-of-string? scan   drop
	dup 1 cell after   lenz   swap !
	pop
;

-- Global named strings...
: string:  ( str -- ) ( -- str )  #immediate
	create   here copys   does
;
-- local anonymous strings
: inline-string ( char -- )
	compile-unconditional-jump
	swap compile-string
	swap jump-target
	compile-literal
;
: s"   #immediate   '"' inline-string   ;

: allot  ( n -- )
	here + dp!
	align-dp
;


-- Sleep

exception: CouldNotSleep

: nsleep ( s ns -- )
	-- sleep for s seconds and ns nanoseconds
	push push
	0 rsp@  SysNanosleep  syscall2
	trash trash
	if raise CouldNotSleep endif
;
: sleep ( n -- ) 
	-- Sleep for n seconds
	0 nsleep
;


-- buffered output

1000 cells buffer constant: OutputBufferStart
variable: output-buffer
OutputBufferStart output-buffer !
: %s  ( s -- )
	-- copy a string into the output buffer
	dup @ push -- length
	1 cell after   peek   output-buffer @   copy-bytes
	pop   output-buffer @   +   output-buffer !
;

: %c  ( c -- )
	-- copy a char into the output buffer
	output-buffer @ !b
	output-buffer inc-var
;

: _c 
	0 -> drop ;;
	_ -> %c tail: _c ;;
;
: %d  ( n -- )
	-- copy an int into the output buffer
	dup 0 < if
		neg
		'-' %c
	endif
	10 decompose
	_c
;

: %f  ( c -- )
	-- copy a decimal into the output buffer
	decimal-places @ times
		10 /mod swap
	repeat
	%d
	'.' %c
	decimal-places @ times
		'0' + %c
	repeat
;

: flush-output
	0   output-buffer @   ! -- guarantee null-termination
	OutputBufferStart putz
	OutputBufferStart output-buffer !
;


-- Date, time and decimal output functions

: leading-zero
	9 <= if   '0' putc   endif
;

: explode-time ( t -- h m s )
	60 /mod push
	60 /mod push
	pop pop
;
: puttime  ( t -- )
	explode-time
	push push
	dup       leading-zero putn   ':' putc
	pop dup   leading-zero putn   ':' putc
	pop dup   leading-zero putn
;

146097 constant: 4Centuries
36524  constant: 1Century
1461   constant: 4Years
365    constant: 1Year
153    constant: 5Months

1600   constant: BaseDate

: _make-year  ( 4cs 1c 4ys 1y 5ms -- ys )
	2 =  if  1+  endif
	swap    4 *   +
	swap  100 *   +
	swap  400 *   +
	BaseDate +
;
: _make-month-and-day  ( ds -- ms ds )
	stash  31 +   5 *  5Months /   2 +
	pop   over 1+   5Months *   5 /   -   123 +
	push
	dup 13 >= if
		12 -
	endif
	pop
;

: explode-date  ( date -- y m d )
	LilianCorrection 1+ -
	4Centuries /mod 
	4Centuries 1- ->  -- Date is Feb 29th of a 400th year
		drop   1+   400 *   BaseDate +
		2 29
	;;
	1Century /mod
	4Years   /mod   -- stack: 4cs 1cs 4ys r
	4Years 1- ->      -- Date is Feb 29th of a 4th year
		drop 
		1+  4 *
		swap   100 *  +     swap   400 *  +     BaseDate +
		2 29
	;;
	1Year /mod    -- ds: 4cs 1c 4ys 1y r
	stash
	5Months /mod  -- ds: 4cs 1c 4ys 1y 5ms r

	drop _make-year   pop _make-month-and-day
;
: putdate  ( date -- )
	explode-date 
	push push            putn   '-' putc
	pop dup leading-zero putn   '-' putc
	pop dup leading-zero putn
;

: putd  ( decimal -- )
	-- TODO: discard low-order zeroes for neatness
	putsign
	decimal-places @ times
		10 /mod swap
	repeat
	putn
	'.' putc
	decimal-places @ times
		'0' + putc
	repeat
;

60 60 *      constant: Hour
Hour 24 *    constant: SecondsInADay
1970-01-01   constant: UnixEpoch

variable: tz

: hour Hour * ;
' hour alias: hours

: GMT ;
: BST  1 hour + ;

' GMT tz !

: now ( -- date time )
	-- WARNING: time is UTC.
	0 SysTime syscall1
	tz @ call
	SecondsInADay /mod push   UnixEpoch +   pop
;
: today ( -- date ) now drop ;
: time  ( -- time ) now nip  ;

: decimal-scaling-factor s" 1.0" number drop ;

: decimal-places  #hidden
	dup 8 > if
		s" Warning: integers cannot be represented at this precision.\n" warns
	endif
	decimal-places ! 
; #visible

: *d  ( n d -- n )
	-- multiply a number by a decimal, rescaling
	-- the result to the same number of decimal
	-- places as n
	decimal-scaling-factor */
;
: /d   ( n d -- n )
	-- ...same for division
	decimal-scaling-factor swap */
;

2 decimal-places ;


-- Fixed-point "constants"...
: pi ( -- d )
	s" 3.1415926535898" number drop
;


: %0d
	dup 
	9 <= if   '0' %c   endif
	%d
;
: %date  ( date -- )
	-- copy a date into the output buffer
	explode-date push push
	%d '-' %c
	pop %0d '-' %c
	pop %0d
;

: %time  ( time -- )
	-- copy a time into the output buffer
	explode-time push push
	%0d ':' %c
	pop %0d ':' %c
	pop %0d
;


-- Concatenative style combinators

: ifte  ( S bool then else -- T )
	push push
	if trash pop else pop trash endif
	call
;
: for  ( S n lambda -- T )
	-- apply lambda to S n times
	push
	0 -> drop trash ;;
	_ -> peek swap 1- push call pop pop tail: for ;;
;
: while ( S lambda -- T )
	push
	0 -> drop trash ;;
	_ -> peek call pop tail: while ;;
;
: dip  ( S x lambda -- T x )
	swap push call pop
;

-- vim:ft=cantilever
